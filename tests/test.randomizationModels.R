################################################################################
# Objects and functions to work with models
################################################################################

library(testthat)
context("Randomization Model Tests")

test_that("Basics", {
  # tau helper returns the passed in tau value:
  expect_equal(returnTau(beta = 1, 3, 4, tau = 5, 7, gamma = -3), 5)

  # test the constant additive model
  uniformity <- c(0, 1, 2, 4)
  Z <- c(0, 1, 0, 1)
  true.tau <- 3
  expected <- c(0, 4, 2, 7)
  
  expect_true(inherits(constant.additive.model, "function"))
  expect_equal(
    constant.additive.model(expected, Z, tau = true.tau),
    uniformity)
  
})

test_that("Level Effect Models", {
  # level effect models have an effect for each level of Z
  uniformity <- 1:4
  Z <- 0:3 # start from level 0 not 1
  
  # the effect of each level 1 to 4
  f1 <- function(x) 3 * x
  f2 <- sqrt
  f3 <- cos
  f4 <- sin

  y <- c(f1(1), f2(2), f3(3), f4(4))

  model <- LevelEffectModel(c(f1,f2,f3,f4))

  expect_equal(model(y, z), uniformity)
  
})

# test_that("Network models", {
#   # super duper simple network model
#   # get an effect of 1 if any neighbors, zero otherwise
#   # network: 1 <-> 2, 2 <-> 3, 4 has no neighbors
#   S <- matrix(c(0,1,0,0, 1,0,1,0, 0,1,0,0, 0,0,0,0), nrow = 4)
#   uniformity <- c(0,1,2,4)
#   Z <- c(0, 1, 0, 0)
#   true.tau <- 3
#   expected.output <- c(1, 4, 3, 4)
#   sdsn.model <- networkRandomizationModel(S, returnTau, 
#     function(Z, ZS, tau) {
#       ifelse(ZS > 0, 1, 0)  
#     })
# 
#   expect_equal(sdsn.model(expected.output, Z, tau = true.tau),
#     uniformity)
# 
#   expect_equal(invertModel(sdsn.model, uniformity, Z, tau = true.tau),
#     expected.output)
# 
# })

test_that("functions", {
  # functions should work as modelsOfEffect and observedData first arguments
  constant.additive.moe <- function(ys, z, b, tau) {
    ys - (z * tau)
  } 
  constant.additive.obdata <- function(ys, z, b, tau) {
    ys + (z * tau)
  } 
  
  data <- 1:6
  Z <- rep(c(1,0), 3)
  true.tau <- 4

  expect_equal(
    constant.additive.model(data, Z, tau = true.tau),
    constant.additive.moe(data, Z, null, tau = true.tau))

  expect_equal(
    invertModel(constant.additive.model, data, Z, tau = true.tau),
    constant.additive.obdata(data, Z, null, tau = true.tau))

  
})

test_that("Model Analysis Functions", {
  
  Z <- c(1,0,1,0)
  data <- c(1,2,3,4)

  res.analysis <- analyzeModel(constant.additive.model,
                               Z,
                               list(tau = 3), 
                               list(tau = 0:5),
                               mean.difference)

  expect_equal(length(res.analysis$simulation), 6)

  expect_is(res.analysis$simulation[[1]], "ParameterizedRandomizationDistribution")

  res.ts <- testSize(res.analysis) # using "auto" alphas should give back 0.333, 0.666, and 1
  expect_equal(dim(res.ts), c(3,2))
  # all alphas should be achieved
  expect_true(all(res.ts[,1] <= res.ts[,2]))
})

test_that("Error checking", {
  Z <- c(1,0,1,0)
  data <- c(1,2,3,4)

  expect_error(analyzeModel(constant.additive.model,
                               Z,
                               list(tau = 3), 
                               list(tau = 0:5, beta = 1),
                               mean.difference))
  
})
