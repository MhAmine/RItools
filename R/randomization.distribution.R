# require(gmp)

# an arbitrarily exact n choose k algorithm
# this could be replace by an approximation, as we only need to 
# know if nCk is larger than samples, where samples is probably@#
# a normal int or a long.
# MF: are you aware that R provides "lchoose()", which unlike choose()
# doesn't get choked up on big integers?  You might use lchoose()
# and compare to log(samples). But maybe you knew that and have 
# a reason not to. -BH
bigchoose <- function(n, k) {
  if (n < 1 || k < 1 || k > n) {
    return(as.bigz(0))  
  }

  if (n == k) {
    return(as.bigz(1))  
  }

  if( k > (n / 2)) {
    k <- n - k;
  }

  numer <- as.bigz(1)
  for (i in n:(n - k + 1)) {
    numer <- numer * i
  }

  denom <- as.bigz(1)
  for (i in 1:k) {
    denom <- denom * i  
  }

  return(numer / denom)
}
stopifnot(choose(10, 3) == bigchoose(10, 3))
stopifnot(bigchoose(3, 0) == 0)





###################################################
### Randomization distribution producing function
###################################################


produceRandomizations <- function(observed.treatment, blocks, samples) {
  if(!is.factor(blocks)){blocks<-factor(blocks)}
  # block size and the number of treated per block
  block.size <- table(blocks)
  block.treated <- aggregate(observed.treatment, list(blocks), sum)$x
  # these offsets will be needed later to turn relative into absolute indices
  block.starts <- append(0, cumsum(block.size))
  block.starts <- block.starts[1:(length(block.starts) - 1)]

  # overall statistics
  total.treated <- sum(observed.treatment)
  total.randomizations <- 1 # thers is a bug in BigIntegers that requires a loop. ??Contact them? Fix it?
  for (i in 1:(nlevels(blocks))) {
    total.randomizations = 
      total.randomizations * bigchoose(block.size[i], block.treated[i])
    NULL
  }
  # randomizations is a matrix (often abbreviated omega) of 
  # possible randomziations, for now ignoring blocks
  # it is generated either by direct enumeration (if small enough)
  # or by drawing from the distribution of randomizations
  if (total.randomizations > samples) {
    randomizations <- matrix(nrow = total.treated, ncol = samples)

    for (i in 1:samples) {
      raw.draws <- mapply(sample.int, block.size, block.treated, SIMPLIFY = F)
      randomizations[, i] <- unlist(mapply(function(b,o) { b + o }, raw.draws, block.starts))
    NULL }
  } else { # small enough to figured exactly 
    # we first get all the block level samples (these vary in size
    block.combinations <- mapply(combn, block.size, block.treated, SIMPLIFY = F)
        
    block.combinations <- mapply(function(b,o) { b + o }, block.combinations, block.starts, SIMPLIFY = FALSE)
    # then all the indexes we need to get unique permutations of block.combs
    expansions <- 
      expand.grid(
        mapply(seq, 
               rep(1, length(block.size)), 
               sapply(block.combinations, function(b) { dim(b)[2] }),
               SIMPLIFY = F))
    
    # loop thru, creating a unique set of combinations
    exp.count <- dim(expansions)[1]
    stopifnot(exp.count == total.randomizations)

    randomizations <- matrix(nrow = total.treated, ncol = exp.count)
    for(i in 1:exp.count) {
      # from each block, grab the combination indexed by the row in expansions
      # combine all such items into a row in randomizations
      randomizations[,i] <- unlist(
        mapply(function(block, i) { block[, i] }, 
               block.combinations, 
               expansions[i,]))
      NULL
    }
  }

  return(randomizations)
}

# some utility classes
setClassUnion("OptionalList", c("list", "NULL"))
setClassUnion("OptionalMatrix", c("matrix", "NULL"))

# the RandomizationDistribution object
# for a single test statistic
# results of a call to randomizationDistribution
# each distribution is with respect to a given test statistic
setClass("RandomizationDistribution",
  representation(test.statistic = "function",
                 models.of.effect = "OptionalList", # of functions
                 treatment = "numeric", # 1/0 vector 
                 blocks = "numeric", # indicator vector
                 samples = "numeric", # number of samples
                 distribution = "OptionalMatrix",
                 sharp.null = "vector"))


randomizationDistributionEngine <- function(
  data,
  treatment,
  models = NULL, # a list of list(testStatistic, moe1, moe2, ...) all functions
  blocks = NULL,
  samples = 5000,
  ...) {

  n <- length(treatment)
  if (is.null(blocks)) blocks <- rep(TRUE, n)
  blocks <- as.factor(blocks)
  stopifnot(n == length(treatment) && n == length(blocks))
  
  # note: it might be better to pass total pool, number of treatment, and a
  # vector of the size of the blocks. Rather than a vector indicating
  # treatment and a vector indicating block membership. keeping this signature
  # for now, but will think about it...
  randomizations <- produceRandomizations(treatment, blocks, samples)
  
  expand.z <- function(i) { a <- numeric(n); a[i] <- 1; return(a) }

  k <- length(models)
  distributions <- vector("list", k)
   
  for (i in 1:k) {
    this.model <- models[[i]]
    test.statistic <- this.model[[1]]
    this.distrib <- NULL
    moes <- NULL

    if (length(this.model[-1]) > 0) {
      moes <- this.model[-1]
    
      # first, for each model, adjust the observed data with the observed
      # treatment indicator
      adjusted.data <- sapply(moes, function(m) m(data, treatment, blocks, ...))

      # now iterate over the randomizations, using the adjusted data
      this.distrib <- apply(randomizations, 2, function(z) {
        z <- expand.z(z)
        apply(adjusted.data, 2, function(d) { 
          test.statistic(d, z, blocks, ...)})})

      # the format of a distribution is an m x k + 1 matrix, where
      # m is the number of models tested, and k is the number of randomizations
      # the extra column is the first column: test statistics under adjustment
      # to be used by the p-value functions
      adjusted.stats <- apply(adjusted.data, 2, function(d) { 
        test.statistic(d, treatment, blocks, ...)})
      this.distrib <- cbind(adjusted.stats, this.distrib)
    }
    
    # every model has the same sharp null: no adjustment to the data
    sharp.null <- apply(randomizations, 2, function(z) {
      z <- expand.z(z)
      test.statistic(data, z, blocks, ...)
    })
    sharp.null <- c(test.statistic(data, treatment, blocks, ...),
                    sharp.null)
    
    distributions[[i]] <- new("RandomizationDistribution",
      test.statistic = test.statistic,
      models.of.effect = moes,
      treatment = as.numeric(treatment),
      blocks = as.numeric(blocks),
      samples = samples,
      distribution = this.distrib,   
      sharp.null = sharp.null)
  }
  # temporary hack until I can get the intialize() method working
  names(distributions) <- names(models)

  return(distributions)
}

# front end as per Ben's recommendation. parameters are specified, not fns.
setClass("ParameterizedRandomizationDistribution",
  representation(
    call = "call",
    params = "data.frame"),
  contains = "RandomizationDistribution")

parameterizedRandomizationDistribution <- function(
  data,
  treatment,
  test.stat,
  moe = NULL, # single function with signature f(data, z, blocks, param1, param2, etc.)
  parameters = NULL, # list of name = values, name = values, ...
  blocks = NULL,
  samples = 5000) {
  
  # if either moe or parameters are present, both must be present
  if ((!is.null(moe) & is.null(parameters)) | (is.null(moe) & !is.null(parameters))) {
    stop("You must supply both parameters and a model effects if you supply either")
  }

  if (!is.null(moe) & !is.function(moe)) {
    stop("moe must be a function")  
  }

  if (!is.null(parameters) & !is.list(parameters)) {
    stop("Parameters must be a list")   
  }

  if (!is.null(parameters)) {
    parameter.space <- do.call(expand.grid, parameters)
    
    functions <- apply(parameter.space, 1, function(params) {
      force(params)
      function(data, z, blocks) {
        do.call(moe, c(list(data, z, blocks), params))
      }
    })

    rds <- randomizationDistributionEngine(data, treatment, models = list(c(test.stat,
      functions)), blocks, samples)
  } else {
    rds <- randomizationDistributionEngine(data, treatment, 
      models = list(c(test.stat)), blocks, samples)
  }

  rd <- as(rds[[1]], "ParameterizedRandomizationDistribution")

  if (!is.null(parameters)) {
    rd@params <- parameter.space
  }

  rd@call <- match.call()

  return(rd)
}

setClass("ParameterizedRandomizationDistributionSummary",
  representation(
    randomizationDistribution = "ParameterizedRandomizationDistribution",
    point.estimate = "data.frame",
    showCall = "logical",
    sharp.null.p = "numeric"))

setMethod("summary", "ParameterizedRandomizationDistribution", function(object, 
  p.value.function = general.two.sided.p.value, showCall = T, ...) {

  # point estimate(s)
  pvs <- p.values(object, p.value.function)
  maxp <- max(pvs$p)
  point.estimate <- pvs[pvs$p == maxp, ]
  rownames(point.estimate) <- NULL
  
  # observed test statistic is in the PRD object but we compute p-value against
  # the sharp null here
  sharp.null.p <- p.value.function(object@sharp.null[1], object@sharp.null[-1])

  return(new("ParameterizedRandomizationDistributionSummary", randomizationDistribution = object,
    point.estimate = point.estimate, showCall = showCall, sharp.null.p = sharp.null.p))
})

setMethod("show", "ParameterizedRandomizationDistributionSummary", function(object) {
  if (object@showCall) {
    dc <- deparse(object@randomizationDistribution@call)
    cat("Call: ", dc[1], "\n")
    cat(paste("      ", dc[-1] , "\n", sep = ""))
    cat("\n")
  }

  tmp <- matrix(c(object@randomizationDistribution@sharp.null[1], object@sharp.null.p), 
    nrow = 1, byrow = T)

  rownames(tmp) <- c("Observed Test Statistic")
  colnames(tmp) <- c("Value", "Pr(>x)")
  printCoefmat(tmp, has.Pvalue = T, P.values = T) 
  cat("\n")

  # save and show the call to x@randomizationDistribution
  cat("Hodges-Lehmann Point Estimate(s):\n")
  print(object@point.estimate)


  invisible(object)
})

setMethod("show", "ParameterizedRandomizationDistribution", function(object) {
  show(summary(object))
})



